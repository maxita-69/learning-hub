<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrow Functions e this in JavaScript</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            border-bottom: 3px solid #2c3e50;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1em;
            color: #7f8c8d;
            font-style: italic;
        }
        
        h2 {
            font-size: 1.8em;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        h3 {
            font-size: 1.3em;
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            border-left: 4px solid #3498db;
        }
        
        .code-block pre {
            margin: 0;
            white-space: pre;
        }
        
        .keyword {
            color: #ff79c6;
        }
        
        .function {
            color: #50fa7b;
        }
        
        .string {
            color: #f1fa8c;
        }
        
        .comment {
            color: #6272a4;
            font-style: italic;
        }
        
        .operator {
            color: #ff79c6;
        }
        
        .output {
            background-color: #1e1e1e;
            color: #4ec9b0;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            border-left: 4px solid #4ec9b0;
        }
        
        .inline-code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            color: #e74c3c;
            font-size: 0.95em;
        }
        
        .important {
            background-color: #d1ecf1;
            border-left: 4px solid #0c5460;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .important strong {
            color: #0c5460;
        }
        
        .warning {
            background-color: #fff3cd;
            border-left: 4px solid #856404;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .warning strong {
            color: #856404;
        }
        
        .concept-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .concept-box h4 {
            color: white;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        .comparison-table th {
            background-color: #3498db;
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Arrow Functions e this in JavaScript</h1>
            <p class="subtitle">Comportamento del Contesto di Esecuzione e Differenze Fondamentali</p>
        </header>

        <section>
            <h2>Introduzione: Oltre la Sintassi</h2>
            <p>
                Le <strong>arrow functions</strong>, introdotte in ES6, rappresentano molto pi√π di una semplice 
                sintassi semplificata per definire funzioni. La differenza fondamentale tra arrow functions 
                e funzioni classiche non risiede nella brevit√† del codice, ma nel <strong>comportamento 
                radicalmente diverso del contesto di esecuzione</strong>, ovvero il valore di 
                <span class="inline-code">this</span>.
            </p>

            <p>
                Questa differenza comportamentale ha profonde implicazioni pratiche e rappresenta uno degli 
                aspetti pi√π sottili e potenti del linguaggio JavaScript moderno. Comprendere quando e perch√© 
                usare arrow functions rispetto a funzioni classiche √® essenziale per scrivere codice JavaScript 
                professionale e privo di bug legati al contesto.
            </p>

            <div class="concept-box">
                <h4>Concetto Chiave</h4>
                <p>
                    Le arrow functions <strong>non hanno un proprio <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">this</span></strong>. 
                    Invece, ereditano il <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">this</span> 
                    dal contesto lessicale in cui sono definite, saltando il loro contesto immediato e 
                    riferendosi al contesto del loro contesto.
                </p>
            </div>
        </section>

        <section>
            <h2>Setup dell'Esperimento: var, let e const</h2>
            
            <p>
                Prima di esplorare il comportamento di <span class="inline-code">this</span> nelle arrow functions, 
                √® fondamentale comprendere come diverse modalit√† di dichiarazione di variabili influenzano 
                l'oggetto globale <span class="inline-code">window</span>.
            </p>

            <h3>Differenze tra var, let e const con l'oggetto window</h3>

            <p>
                Quando dichiariamo variabili con <span class="inline-code">let</span> o 
                <span class="inline-code">const</span>, queste variabili <strong>non vengono aggiunte</strong> 
                come propriet√† all'oggetto globale <span class="inline-code">window</span>.
            </p>

            <div class="code-block"><pre><span class="comment">// Dichiarazione con let</span>
<span class="keyword">let</span> user = {
    nome: <span class="string">"Mario"</span>
};

<span class="comment">// Tentativo di accesso tramite window</span>
<span class="function">console</span>.<span class="function">log</span>(window.user);</pre>
            </div>

            <div class="output">Output: undefined</div>

            <p>
                Se ispezioniamo l'oggetto <span class="inline-code">window</span>, 
                non troveremo la propriet√† <span class="inline-code">user</span>:
            </p>

            <div class="code-block"><pre><span class="function">console</span>.<span class="function">log</span>(window);
<span class="comment">// Nell'output non c'√® window.user</span></pre>
            </div>

            <h3>Il Comportamento Speciale di var</h3>

            <p>
                Al contrario, quando utilizziamo <span class="inline-code">var</span>, 
                la variabile viene automaticamente aggiunta come propriet√† dell'oggetto 
                <span class="inline-code">window</span>:
            </p>

            <div class="code-block"><pre><span class="comment">// Dichiarazione con var</span>
<span class="keyword">var</span> user = {
    nome: <span class="string">"Mario"</span>
};

<span class="comment">// Ora possiamo accedervi tramite window</span>
<span class="function">console</span>.<span class="function">log</span>(window.user);</pre>
            </div>

            <div class="output">Output: { nome: "Mario" }</div>

            <div class="important">
                <strong>Per questo esempio</strong>: Utilizzeremo <span class="inline-code">var</span> 
                per dichiarare l'oggetto <span class="inline-code">user</span>, cos√¨ da poterlo 
                accedere tramite <span class="inline-code">window.user</span> e dimostrare 
                chiaramente il comportamento di <span class="inline-code">this</span> nelle arrow functions.
            </div>
        </section>

        <section>
            <h2>Definizione dell'Oggetto di Test</h2>
            
            <p>
                Creiamo un oggetto <span class="inline-code">user</span> con due metodi identici 
                nella funzionalit√† ma diversi nella definizione: uno con sintassi classica e uno 
                con arrow function.
            </p>

            <div class="code-block"><pre><span class="comment">// Oggetto user con var per aggiungerlo a window</span>
<span class="keyword">var</span> user = {
    nome: <span class="string">"Mario"</span>,
    
    <span class="comment">// Metodo con sintassi classica</span>
    fn: <span class="keyword">function</span>() {
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>);
    },
    
    <span class="comment">// Metodo con arrow function</span>
    fn2: () => {
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>);
    }
};</pre>
            </div>

            <p>
                Entrambi i metodi eseguono la stessa operazione: stampano il valore di 
                <span class="inline-code">this</span>. Tuttavia, come vedremo, il risultato 
                sar√† completamente diverso.
            </p>
        </section>

        <section>
            <h2>L'Esperimento: Invocazione dei Metodi</h2>
            
            <p>
                Invochiamo entrambi i metodi per osservare il comportamento di 
                <span class="inline-code">this</span>:
            </p>

            <div class="code-block"><pre><span class="comment">// Invocazione metodo con sintassi classica</span>
user.<span class="function">fn</span>();

<span class="comment">// Invocazione metodo con arrow function</span>
user.<span class="function">fn2</span>();</pre>
            </div>

            <h3>Risultati dell'Esperimento</h3>

            <div class="output">
<strong>user.fn():</strong>
{ nome: "Mario", fn: [Function], fn2: [Function] }
‚Üë Oggetto user completo

<strong>user.fn2():</strong>
Window {...}
‚Üë Oggetto window globale
            </div>

            <div class="concept-box">
                <h4>Analisi dei Risultati</h4>
                <p>
                    <strong>1. Funzione Classica (<span class="inline-code" style="background-color: rgba(255,255,255,0.2);">fn</span>):</strong><br>
                    <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">this</span> 
                    fa riferimento all'<strong>oggetto user</strong>, ovvero il contesto diretto di invocazione 
                    del metodo. Questo √® il comportamento standard che ci aspettiamo.
                </p>
                <p style="margin-top: 15px;">
                    <strong>2. Arrow Function (<span class="inline-code" style="background-color: rgba(255,255,255,0.2);">fn2</span>):</strong><br>
                    <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">this</span> 
                    <strong>NON</strong> fa riferimento a <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">user</span>, 
                    ma all'<strong>oggetto window</strong>. Salta il suo contesto immediato (user) e 
                    si lega al contesto del contesto di user.
                </p>
            </div>
        </section>

        <section>
            <h2>Il Meccanismo: "Contesto del Contesto"</h2>
            
            <p>
                Per comprendere pienamente questo comportamento, dobbiamo analizzare la 
                <strong>catena dei contesti di esecuzione</strong>:
            </p>

            <h3>Analisi della Catena di Contesti</h3>

            <div class="code-block"><pre><span class="comment">// Possiamo accedere all'oggetto user anche tramite window</span>
window.user.<span class="function">fn</span>();   <span class="comment">// this ‚Üí user</span>
window.user.<span class="function">fn2</span>();  <span class="comment">// this ‚Üí window</span></pre>
            </div>

            <p>
                Quando la arrow function <span class="inline-code">fn2</span> viene eseguita, 
                avviene il seguente processo di risoluzione del contesto:
            </p>

            <ol>
                <li><strong>Contesto immediato</strong>: La funzione √® chiamata come 
                    <span class="inline-code">user.fn2()</span>, quindi il contesto immediato 
                    √® <span class="inline-code">user</span></li>
                
                <li><strong>Arrow function salta il contesto immediato</strong>: Invece di 
                    usare <span class="inline-code">user</span> come <span class="inline-code">this</span>, 
                    l'arrow function cerca il contesto del suo contesto</li>
                
                <li><strong>Contesto di user</strong>: L'oggetto <span class="inline-code">user</span> 
                    √® stato definito nel contesto globale, il cui <span class="inline-code">this</span> 
                    √® <span class="inline-code">window</span></li>
                
                <li><strong>Risoluzione finale</strong>: <span class="inline-code">this</span> 
                    nell'arrow function fa riferimento a <span class="inline-code">window</span></li>
            </ol>

            <div class="important">
                <strong>Regola chiave delle Arrow Functions:</strong> 
                <span class="inline-code">this</span> in una arrow function <strong>non fa riferimento 
                al suo contesto diretto di invocazione</strong>, ma al contesto in cui la funzione 
                √® stata <strong>definita lessicalmente</strong>. In altre parole, l'arrow function 
                "eredita" il <span class="inline-code">this</span> dall'ambiente circostante.
            </div>

            <h3>Visualizzazione della Catena</h3>

            <div class="code-block"><pre><span class="comment">// Struttura dei contesti</span>

<span class="comment">// Livello 1: Contesto Globale (window)</span>
<span class="comment">//    this = window</span>
<span class="comment">//    √¢"‚Äö</span>
<span class="comment">//    √¢""√¢"‚Ç¨√¢"‚Ç¨√¢"‚Ç¨> Livello 2: Oggetto user</span>
<span class="comment">//           this in user = window</span>
<span class="comment">//           √¢"‚Äö</span>
<span class="comment">//           √¢"≈ì√¢"‚Ç¨√¢"‚Ç¨√¢"‚Ç¨> fn (funzione classica)</span>
<span class="comment">//           √¢"‚Äö     this = user (contesto diretto)</span>
<span class="comment">//           √¢"‚Äö</span>
<span class="comment">//           √¢""√¢"‚Ç¨√¢"‚Ç¨√¢"‚Ç¨> fn2 (arrow function)</span>
<span class="comment">//                 this = window (contesto di user)</span></pre>
            </div>
        </section>

        <section>
            <h2>Dimostrazione Pratica: Accesso alle Propriet√†</h2>
            
            <p>
                Per rendere ancora pi√π evidente la differenza, modifichiamo i metodi per 
                accedere alla propriet√† <span class="inline-code">nome</span>:
            </p>

            <div class="code-block"><pre><span class="keyword">var</span> user = {
    nome: <span class="string">"Mario"</span>,
    
    <span class="comment">// Funzione classica</span>
    fn: <span class="keyword">function</span>() {
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.nome);
    },
    
    <span class="comment">// Arrow function</span>
    fn2: () => {
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.nome);
    }
};

user.<span class="function">fn</span>();   <span class="comment">// Accede a this.nome dove this = user</span>
user.<span class="function">fn2</span>();  <span class="comment">// Accede a this.nome dove this = window</span></pre>
            </div>

            <h3>Output Risultante</h3>

            <div class="output">
<strong>user.fn():</strong>
"Mario"
‚Üë Accede a user.nome

<strong>user.fn2():</strong>
undefined
‚Üë Accede a window.nome (che non esiste)
            </div>

            <div class="important">
                <strong>Spiegazione:</strong>
                <ul>
                    <li><strong>fn()</strong>: Poich√© <span class="inline-code">this</span> 
                        fa riferimento a <span class="inline-code">user</span>, 
                        <span class="inline-code">this.nome</span> restituisce 
                        <span class="inline-code">"Mario"</span></li>
                    
                    <li><strong>fn2()</strong>: Poich√© <span class="inline-code">this</span> 
                        fa riferimento a <span class="inline-code">window</span>, 
                        <span class="inline-code">this.nome</span> cerca 
                        <span class="inline-code">window.nome</span>, che non esiste, 
                        risultando in <span class="inline-code">undefined</span></li>
                </ul>
            </div>
        </section>

        <section>
            <h2>La Logica dietro il Comportamento</h2>
            
            <p>
                A prima vista, questo comportamento delle arrow functions pu√≤ sembrare controintuitivo 
                o addirittura privo di logica. Tuttavia, esiste una <strong>motivazione precisa</strong> 
                e un'<strong>utilit√† pratica</strong> per questo design.
            </p>

            <h3>Il Problema che Risolvono le Arrow Functions</h3>

            <p>
                Prima dell'introduzione delle arrow functions, uno dei problemi pi√π comuni in JavaScript 
                era la perdita del contesto <span class="inline-code">this</span> nei callback e 
                nelle funzioni annidate. Consideriamo questo scenario classico:
            </p>

            <div class="code-block"><pre><span class="comment">// PROBLEMA CLASSICO (prima delle arrow functions)</span>
<span class="keyword">var</span> oggetto = {
    valore: <span class="string">42</span>,
    
    metodo: <span class="keyword">function</span>() {
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.valore); <span class="comment">// 42 - this √® oggetto</span>
        
        <span class="function">setTimeout</span>(<span class="keyword">function</span>() {
            <span class="comment">// Problema: this qui NON √® pi√π oggetto!</span>
            <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.valore); <span class="comment">// undefined!</span>
        }, <span class="string">1000</span>);
    }
};</pre>
            </div>

            <p>
                Prima di ES6, dovevamo usare workaround come <span class="inline-code">var self = this</span>:
            </p>

            <div class="code-block"><pre><span class="comment">// SOLUZIONE PRE-ES6 (workaround)</span>
<span class="keyword">var</span> oggetto = {
    valore: <span class="string">42</span>,
    
    metodo: <span class="keyword">function</span>() {
        <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// Salviamo il riferimento</span>
        
        <span class="function">setTimeout</span>(<span class="keyword">function</span>() {
            <span class="function">console</span>.<span class="function">log</span>(self.valore); <span class="comment">// 42 - funziona!</span>
        }, <span class="string">1000</span>);
    }
};</pre>
            </div>

            <h3>La Soluzione delle Arrow Functions</h3>

            <p>
                Le arrow functions risolvono questo problema elegantemente ereditando 
                <span class="inline-code">this</span> dal contesto lessicale:
            </p>

            <div class="code-block"><pre><span class="comment">// SOLUZIONE ES6 (con arrow function)</span>
<span class="keyword">const</span> oggetto = {
    valore: <span class="string">42</span>,
    
    metodo: <span class="keyword">function</span>() {
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.valore); <span class="comment">// 42</span>
        
        <span class="function">setTimeout</span>(() => {
            <span class="comment">// Arrow function: eredita this da metodo()</span>
            <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.valore); <span class="comment">// 42 - funziona!</span>
        }, <span class="string">1000</span>);
    }
};</pre>
            </div>

            <div class="concept-box">
                <h4>Perch√© Funziona</h4>
                <p>
                    L'arrow function all'interno di <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">setTimeout</span> 
                    <strong>non crea un proprio contesto</strong>. Invece, eredita il 
                    <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">this</span> 
                    dalla funzione <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">metodo()</span> 
                    in cui √® definita, dove <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">this</span> 
                    fa riferimento a <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">oggetto</span>.
                </p>
            </div>
        </section>

        <section>
            <h2>Quando Usare Funzioni Classiche vs Arrow Functions</h2>
            
            <p>
                La scelta tra sintassi classica e arrow functions non √® solo una questione di 
                preferenza stilistica, ma deve essere basata sul <strong>comportamento desiderato</strong> 
                di <span class="inline-code">this</span>.
            </p>

            <h3>Usa Funzioni Classiche Quando</h3>

            <div class="code-block"><pre><span class="comment">// 1. Metodi di oggetti che accedono alle loro propriet√†</span>
<span class="keyword">const</span> persona = {
    nome: <span class="string">"Anna"</span>,
    et√†: <span class="string">30</span>,
    
    <span class="comment">// √¢≈ì‚Ä¶ CORRETTO: funzione classica</span>
    saluta: <span class="keyword">function</span>() {
        <span class="keyword">return</span> <span class="string">`Ciao, sono ${<span class="keyword">this</span>.nome} e ho ${<span class="keyword">this</span>.et√†} anni`</span>;
    }
};

<span class="function">console</span>.<span class="function">log</span>(persona.<span class="function">saluta</span>());
<span class="comment">// "Ciao, sono Anna e ho 30 anni"</span></pre>
            </div>

            <div class="code-block"><pre><span class="comment">// 2. Constructor functions</span>
<span class="comment">// √¢≈ì‚Ä¶ CORRETTO: funzione classica</span>
<span class="keyword">function</span> <span class="function">Utente</span>(nome, email) {
    <span class="keyword">this</span>.nome = nome;
    <span class="keyword">this</span>.email = email;
}

<span class="keyword">const</span> utente = <span class="keyword">new</span> <span class="function">Utente</span>(<span class="string">"Mario"</span>, <span class="string">"mario@email.com"</span>);</pre>
            </div>

            <div class="code-block"><pre><span class="comment">// 3. Event handlers che necessitano dell'elemento DOM</span>
<span class="comment">// √¢≈ì‚Ä¶ CORRETTO: funzione classica</span>
button.<span class="function">addEventListener</span>(<span class="string">'click'</span>, <span class="keyword">function</span>() {
    <span class="keyword">this</span>.classList.<span class="function">toggle</span>(<span class="string">'active'</span>); <span class="comment">// this = button</span>
});</pre>
            </div>

            <h3>Usa Arrow Functions Quando</h3>

            <div class="code-block"><pre><span class="comment">// 1. Callback che devono mantenere il contesto esterno</span>
<span class="keyword">const</span> timer = {
    secondi: <span class="string">0</span>,
    
    start: <span class="keyword">function</span>() {
        <span class="comment">// √¢≈ì‚Ä¶ CORRETTO: arrow function mantiene this = timer</span>
        <span class="function">setInterval</span>(() => {
            <span class="keyword">this</span>.secondi++;
            <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.secondi);
        }, <span class="string">1000</span>);
    }
};</pre>
            </div>

            <div class="code-block"><pre><span class="comment">// 2. Array methods che necessitano del contesto esterno</span>
<span class="keyword">const</span> calcolatore = {
    moltiplicatore: <span class="string">2</span>,
    numeri: [<span class="string">1</span>, <span class="string">2</span>, <span class="string">3</span>, <span class="string">4</span>],
    
    moltiplica: <span class="keyword">function</span>() {
        <span class="comment">// √¢≈ì‚Ä¶ CORRETTO: arrow function per mantenere this</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.numeri.<span class="function">map</span>(n => n * <span class="keyword">this</span>.moltiplicatore);
    }
};

<span class="function">console</span>.<span class="function">log</span>(calcolatore.<span class="function">moltiplica</span>());
<span class="comment">// [2, 4, 6, 8]</span></pre>
            </div>

            <div class="code-block"><pre><span class="comment">// 3. Funzioni che non accedono a propriet√† dell'oggetto</span>
<span class="keyword">const</span> utils = {
    <span class="comment">// √¢≈ì‚Ä¶ OK: arrow function (non usa this)</span>
    somma: (a, b) => a + b,
    
    <span class="comment">// √¢≈ì‚Ä¶ OK: arrow function (non usa this)</span>
    quadrato: (n) => n * n
};</pre>
            </div>

            <h3>Esempio di Scelta Sbagliata</h3>

            <div class="code-block"><pre><span class="comment">// √¢≈í ERRORE: arrow function come metodo di oggetto</span>
<span class="keyword">const</span> persona = {
    nome: <span class="string">"Luca"</span>,
    
    <span class="comment">// √¢≈í SBAGLIATO!</span>
    saluta: () => {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Ciao, sono ${<span class="keyword">this</span>.nome}`</span>);
        <span class="comment">// this sar√† window, non persona!</span>
    }
};

persona.<span class="function">saluta</span>();
<span class="comment">// "Ciao, sono undefined"</span></pre>
            </div>
        </section>

        <section>
            <h2>Tabella Comparativa: Funzioni Classiche vs Arrow Functions</h2>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspetto</th>
                        <th>Funzione Classica</th>
                        <th>Arrow Function</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Sintassi</strong></td>
                        <td><code>function() { }</code></td>
                        <td><code>() => { }</code></td>
                    </tr>
                    <tr>
                        <td><strong>this</strong></td>
                        <td>Dinamico (dipende da come viene chiamata)</td>
                        <td>Lessicale (eredita dal contesto esterno)</td>
                    </tr>
                    <tr>
                        <td><strong>arguments</strong></td>
                        <td>Disponibile</td>
                        <td>Non disponibile</td>
                    </tr>
                    <tr>
                        <td><strong>new</strong></td>
                        <td>Pu√≤ essere usata come constructor</td>
                        <td>Non pu√≤ essere usata come constructor</td>
                    </tr>
                    <tr>
                        <td><strong>Metodi oggetti</strong></td>
                        <td>‚úÖ Consigliato</td>
                        <td>‚ùå Sconsigliato</td>
                    </tr>
                    <tr>
                        <td><strong>Callback</strong></td>
                        <td>Perde il contesto</td>
                        <td>‚úÖ Mantiene il contesto</td>
                    </tr>
                    <tr>
                        <td><strong>Event handlers</strong></td>
                        <td>this = elemento DOM</td>
                        <td>this = contesto esterno</td>
                    </tr>
                    <tr>
                        <td><strong>bind/call/apply</strong></td>
                        <td>‚úÖ Funzionano</td>
                        <td>‚ùå Non hanno effetto</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>Casi d'Uso Avanzati</h2>
            
            <h3>Caso 1: Class Methods con Arrow Functions</h3>

            <div class="code-block"><pre><span class="keyword">class</span> <span class="function">Counter</span> {
    <span class="function">constructor</span>() {
        <span class="keyword">this</span>.count = <span class="string">0</span>;
        
        <span class="comment">// √¢≈ì‚Ä¶ Arrow function come propriet√†</span>
        <span class="comment">// Mantiene this = istanza della classe</span>
        <span class="keyword">this</span>.increment = () => {
            <span class="keyword">this</span>.count++;
            <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.count);
        };
    }
    
    <span class="comment">// Metodo classico</span>
    <span class="function">start</span>() {
        <span class="comment">// √¢≈ì‚Ä¶ Arrow function mantiene il contesto</span>
        <span class="function">setInterval</span>(<span class="keyword">this</span>.increment, <span class="string">1000</span>);
    }
}

<span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="function">Counter</span>();
counter.<span class="function">start</span>();
<span class="comment">// 1, 2, 3, 4... (ogni secondo)</span></pre>
            </div>

            <h3>Caso 2: Nested Functions</h3>

            <div class="code-block"><pre><span class="keyword">const</span> oggetto = {
    valore: <span class="string">100</span>,
    
    metodo: <span class="keyword">function</span>() {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">'Esterno:'</span>, <span class="keyword">this</span>.valore); <span class="comment">// 100</span>
        
        <span class="comment">// Funzione annidata classica</span>
        <span class="keyword">function</span> <span class="function">interno1</span>() {
            <span class="function">console</span>.<span class="function">log</span>(<span class="string">'Classica:'</span>, <span class="keyword">this</span>.valore); <span class="comment">// undefined</span>
        }
        
        <span class="comment">// Arrow function annidata</span>
        <span class="keyword">const</span> interno2 = () => {
            <span class="function">console</span>.<span class="function">log</span>(<span class="string">'Arrow:'</span>, <span class="keyword">this</span>.valore); <span class="comment">// 100</span>
        };
        
        <span class="function">interno1</span>();
        <span class="function">interno2</span>();
    }
};

oggetto.<span class="function">metodo</span>();</pre>
            </div>

            <div class="output">
Esterno: 100
Classica: undefined
Arrow: 100
            </div>
        </section>

        <section>
            <h2>Best Practices e Linee Guida</h2>
            
            <h3>‚úÖ Regole da Seguire</h3>

            <ol>
                <li><strong>Metodi di oggetti</strong>: Usa sempre funzioni classiche se il metodo 
                    accede a propriet√† dell'oggetto tramite <span class="inline-code">this</span></li>
                
                <li><strong>Callback</strong>: Preferisci arrow functions per mantenere il contesto 
                    esterno (setTimeout, setInterval, array methods)</li>
                
                <li><strong>Event handlers</strong>: Valuta caso per caso:
                    <ul>
                        <li>Se hai bisogno dell'elemento DOM ‚Üí funzione classica</li>
                        <li>Se hai bisogno del contesto dell'oggetto ‚Üí arrow function</li>
                    </ul>
                </li>
                
                <li><strong>Constructor functions</strong>: Usa solo funzioni classiche o classi ES6</li>
                
                <li><strong>Funzioni pure</strong>: Le arrow functions sono perfette per funzioni 
                    che non usano <span class="inline-code">this</span></li>
            </ol>

            <h3>‚ùå Errori da Evitare</h3>

            <div class="warning">
                <strong>‚ö†Ô∏è Non usare arrow functions per:</strong>
                <ul>
                    <li>Metodi di oggetti che accedono alle propriet√† con <span class="inline-code">this</span></li>
                    <li>Constructor functions (causeranno errori)</li>
                    <li>Event handlers quando serve l'elemento DOM</li>
                    <li>Metodi che verranno passati a <span class="inline-code">call/apply/bind</span></li>
                </ul>
            </div>
        </section>

        <section>
            <h2>Esercizi Pratici</h2>
            
            <h3>Esercizio 1: Identifica il Problema</h3>

            <div class="code-block"><pre><span class="comment">// Questo codice ha un bug. Qual √® e come lo risolvi?</span>
<span class="keyword">const</span> btn = document.<span class="function">querySelector</span>(<span class="string">'#myButton'</span>);

<span class="keyword">const</span> app = {
    clicks: <span class="string">0</span>,
    
    init: <span class="keyword">function</span>() {
        btn.<span class="function">addEventListener</span>(<span class="string">'click'</span>, <span class="keyword">function</span>() {
            <span class="keyword">this</span>.clicks++; <span class="comment">// Bug: this non √® app!</span>
            <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.clicks);
        });
    }
};

<span class="comment">// TODO: Risolvi il problema</span></pre>
            </div>

            <details>
                <summary><strong>Soluzione</strong></summary>
                <div class="code-block"><pre><span class="comment">// Soluzione 1: Arrow function</span>
init: <span class="keyword">function</span>() {
    btn.<span class="function">addEventListener</span>(<span class="string">'click'</span>, () => {
        <span class="keyword">this</span>.clicks++;
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.clicks);
    });
}

<span class="comment">// Soluzione 2: bind</span>
init: <span class="keyword">function</span>() {
    btn.<span class="function">addEventListener</span>(<span class="string">'click'</span>, <span class="keyword">function</span>() {
        <span class="keyword">this</span>.clicks++;
        <span class="function">console</span>.<span class="function">log</span>(<span class="keyword">this</span>.clicks);
    }.<span class="function">bind</span>(<span class="keyword">this</span>));
}</pre>
                </div>
            </details>

            <h3>Esercizio 2: Converti Correttamente</h3>

            <div class="code-block"><pre><span class="comment">// Converti questo codice usando arrow functions dove appropriato</span>
<span class="keyword">const</span> calculator = {
    numbers: [<span class="string">1</span>, <span class="string">2</span>, <span class="string">3</span>, <span class="string">4</span>, <span class="string">5</span>],
    multiplier: <span class="string">3</span>,
    
    multiplyAll: <span class="keyword">function</span>() {
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>.numbers.<span class="function">map</span>(<span class="keyword">function</span>(n) {
            <span class="keyword">return</span> n * self.multiplier;
        });
    }
};</pre>
            </div>

            <details>
                <summary><strong>Soluzione</strong></summary>
                <div class="code-block"><pre><span class="keyword">const</span> calculator = {
    numbers: [<span class="string">1</span>, <span class="string">2</span>, <span class="string">3</span>, <span class="string">4</span>, <span class="string">5</span>],
    multiplier: <span class="string">3</span>,
    
    <span class="comment">// Metodo: funzione classica</span>
    multiplyAll: <span class="keyword">function</span>() {
        <span class="comment">// Callback: arrow function</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.numbers.<span class="function">map</span>(n => n * <span class="keyword">this</span>.multiplier);
    }
};</pre>
                </div>
            </details>

            <h3>Esercizio 3: Debug</h3>

            <div class="code-block"><pre><span class="comment">// Perch√© questo codice non funziona come previsto?</span>
<span class="keyword">const</span> person = {
    name: <span class="string">"Alice"</span>,
    greet: () => {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Hello, I'm ${<span class="keyword">this</span>.name}`</span>);
    }
};

person.<span class="function">greet</span>(); <span class="comment">// "Hello, I'm undefined" - Perch√©?</span></pre>
            </div>

            <details>
                <summary><strong>Soluzione</strong></summary>
                <p>
                    L'arrow function come metodo dell'oggetto eredita <span class="inline-code">this</span> 
                    dal contesto globale (window), non dall'oggetto <span class="inline-code">person</span>. 
                    Soluzione: usare funzione classica.
                </p>
            </details>
        </section>

        <section>
            <h2>Riepilogo e Punti Chiave</h2>
            
            <div class="important">
                <strong>üéØ Concetti Fondamentali da Ricordare:</strong>
                <ol>
                    <li>Le arrow functions <strong>non hanno un proprio this</strong></li>
                    
                    <li>Arrow functions <strong>ereditano this dal contesto lessicale</strong> 
                        in cui sono definite</li>
                    
                    <li>Funzioni classiche hanno <strong>this dinamico</strong> (dipende dall'invocazione)</li>
                    
                    <li><strong>Metodi di oggetti</strong> ‚Üí Usa funzioni classiche</li>
                    
                    <li><strong>Callback che devono mantenere il contesto</strong> ‚Üí Usa arrow functions</li>
                    
                    <li>La scelta non √® stilistica ma <strong>funzionale</strong></li>
                    
                    <li><span class="inline-code">var</span> aggiunge variabili a 
                        <span class="inline-code">window</span>, 
                        <span class="inline-code">let</span>/<span class="inline-code">const</span> no</li>
                </ol>
            </div>

            <h3>Flowchart Decisionale</h3>

            <div class="code-block"><pre><span class="comment">// Quale tipo di funzione usare?</span>

<span class="comment">// √¢" √à un metodo di un oggetto che usa this?</span>
<span class="comment">//    √¢"≈ì√¢"‚Ç¨ S√É≈í √¢‚Ä†' Funzione classica</span>
<span class="comment">//    √¢""√¢"‚Ç¨ NO √¢‚Ä†' Continua...</span>

<span class="comment">// √¢" Serve mantenere il contesto esterno in un callback?</span>
<span class="comment">//    √¢"≈ì√¢"‚Ç¨ S√É≈í √¢‚Ä†' Arrow function</span>
<span class="comment">//    √¢""√¢"‚Ç¨ NO √¢‚Ä†' Continua...</span>

<span class="comment">// √¢" √à un event handler che usa l'elemento DOM?</span>
<span class="comment">//    √¢"≈ì√¢"‚Ç¨ S√É≈í √¢‚Ä†' Funzione classica</span>
<span class="comment">//    √¢""√¢"‚Ç¨ NO √¢‚Ä†' Continua...</span>

<span class="comment">// √¢" √à una funzione pura senza this?</span>
<span class="comment">//    √¢"≈ì√¢"‚Ç¨ S√É≈í √¢‚Ä†' Arrow function (pi√π concisa)</span>
<span class="comment">//    √¢""√¢"‚Ç¨ NO √¢‚Ä†' Valuta caso per caso</span></pre>
            </div>
        </section>

        <section>
            <h2>Conclusioni</h2>
            
            <p>
                Le arrow functions rappresentano molto pi√π di una sintassi abbreviata: sono uno strumento 
                potente per gestire il contesto di esecuzione in modo prevedibile e lessicale. Comprendere 
                quando e perch√© utilizzare arrow functions rispetto a funzioni classiche √® essenziale per:
            </p>

            <ul>
                <li><strong>Evitare bug legati a this</strong>: Uno dei problemi pi√π comuni in JavaScript</li>
                <li><strong>Scrivere codice pi√π pulito</strong>: Eliminando workaround come 
                    <span class="inline-code">var self = this</span></li>
                <li><strong>Migliorare la leggibilit√†</strong>: Quando il contesto √® chiaro e prevedibile</li>
                <li><strong>Programmare in modo pi√π funzionale</strong>: Arrow functions si integrano 
                    perfettamente con paradigmi funzionali</li>
            </ul>

            <p>
                La regola d'oro √®: <strong>usa la sintassi appropriata basandoti sul comportamento 
                desiderato di <span class="inline-code">this</span></strong>, non solo sulla brevit√† del codice.
            </p>

            <div class="concept-box">
                <h4>üöÄ Prossimi Passi</h4>
                <p>
                    Dopo aver compreso il comportamento di <span class="inline-code" style="background-color: rgba(255,255,255,0.2);">this</span> 
                    nelle arrow functions, esplora:
                </p>
                <ul>
                    <li>Classi ES6 e il loro uso di arrow functions come propriet√†</li>
                    <li>Async/Await e gestione del contesto in funzioni asincrone</li>
                    <li>Pattern avanzati con arrow functions in React e altri framework</li>
                    <li>Closures e scope chain in combinazione con arrow functions</li>
                </ul>
            </div>
        </section>

        <footer>
            <p><strong>Lezione:</strong> Arrow Functions e this in JavaScript</p>
            <p><strong>Corso:</strong> JavaScript - Da Zero ad Esperto</p>
            <p style="margin-top: 15px; font-size: 0.85em;">
                Manuale creato il 26 Dicembre 2024
            </p>
        </footer>
    </div>
</body>
</html>