<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lezione 14 - IEEE 754 Approfondito</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.8; color: #333; background-color: #f5f5f5; padding: 20px; }
        .container { max-width: 900px; margin: 0 auto; background-color: white; padding: 40px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-radius: 8px; }
        header { border-bottom: 3px solid #2c3e50; padding-bottom: 20px; margin-bottom: 30px; }
        h1 { font-size: 2.5em; color: #2c3e50; margin-bottom: 10px; }
        .subtitle { font-size: 1.1em; color: #7f8c8d; font-style: italic; }
        h2 { font-size: 1.8em; color: #2c3e50; margin-top: 40px; margin-bottom: 20px; border-left: 4px solid #3498db; padding-left: 15px; }
        h3 { font-size: 1.3em; color: #34495e; margin-top: 25px; margin-bottom: 15px; }
        h4 { font-size: 1.1em; color: #34495e; margin-top: 20px; margin-bottom: 10px; }
        p { margin-bottom: 15px; text-align: justify; }
        .code-block { background-color: #2d2d2d; color: #f8f8f2; padding: 20px; border-radius: 5px; margin: 20px 0; overflow-x: auto; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 0.95em; line-height: 1.6; border-left: 4px solid #3498db; }
        .code-block pre { margin: 0; white-space: pre; }
        .keyword { color: #ff79c6; }
        .function { color: #50fa7b; }
        .string { color: #f1fa8c; }
        .comment { color: #6272a4; font-style: italic; }
        .inline-code { background-color: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; color: #e74c3c; font-size: 0.95em; }
        .important { background-color: #d1ecf1; border-left: 4px solid #0c5460; padding: 15px; margin: 20px 0; border-radius: 5px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border: 1px solid #ddd; }
        th { background-color: #3498db; color: white; font-weight: bold; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        ul, ol { margin-left: 30px; margin-bottom: 15px; }
        li { margin-bottom: 10px; }
        footer { margin-top: 50px; padding-top: 20px; border-top: 2px solid #ecf0f1; text-align: center; color: #95a5a6; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>IEEE 754 Approfondito</h1>
            <p class="subtitle">Lezione 14 - Corso JavaScript</p>
        </header>
        <section><h2> *üß† Perch√© 0.1 + 0.2 \!== 0.3?*</h2>
<h3> *Comprensione dello Standard IEEE 754 (Floating-Point a 64 bit)*</h3>
<h2> *üîπ 1\. Introduzione: Un Solo Tipo Numerico ‚Äî number*</h2>
<p>In JavaScript *tutti i numeri ‚Äî interi, decimali, positivi, negativi ‚Äî sono di tipo number*.</p>
<ul><li>A differenza di linguaggi come C o Java (che distinguono tra int, float, double), in JavaScript non c‚Äô√® distinzione nativa tra tipi numerici decimali e interi:</li><li>JavaScript</li></ul>
<p>typeof 42    // ‚Üí "number"</p>
<p>typeof 3.14  // ‚Üí "number"</p>
<p>typeof -7    // ‚Üí "number"</p>
<p>*</p>
<p>*</p>
<p>üìå *Nota: Fino a ES2020, number era l‚Äôunico tipo. Solo con BigInt (introdotta in ES2020) √® arrivata la possibilit√† di rappresentare interi arbitrariamente grandi, ma per i decimali, number* rimane l‚Äôunica opzione.</p>
<h2> *üîπ 2\. Lo Standard IEEE 754: Virgola Mobile a 64 bit*</h2>
<p>JavaScript memorizza *ogni numero (sia intero che decimale) usando lo standard [IEEE 754](https://it.wikipedia.org/wiki/IEEE_754) in doppia precisione (64 bit*).</p>
<h3> *üì¶ Struttura dei 64 bit*</h3>
<p>‚úÖ *Esempio Concettuale: Il numero intero 1 non √® memorizzato come semplice 1, ma come: +1.0 √ó 2‚Å∞* (segno = +, mantissa = 1.0, esponente = 0).</p>
<h2> *üîπ 3\. Il Problema: Rappresentazione Binaria (Base 2\)*</h2>
<p>Il cuore del famoso problema di approssimazione risiede nel fatto che il computer usa la *base 2*, non la base 10 che usiamo noi.</p>
<p>Proprio come 1/3 = 0.333... √® un numero periodico infinito in base 10, molti numeri decimali come 0.1 o 0.2 sono *periodici infiniti in base 2*.</p>
<h3> *Esempio: 0.1 in Binario*</h3>
<p>$$0.1_{10} = 0.00011001100110011..._2 = 0.\\overline{00011}_2$$</p>
<p>‚Üí Poich√© la mantissa ha solo *52 bit, il valore periodico viene troncato e arrotondato*.</p>
<h3> *Risultato: L'Errore di Approssimazione*</h3>
<p>Le leggere approssimazioni di 0.1 e 0.2 si sommano, creando un risultato non esatto.</p>
<p>JavaScript</p>
<p>0.1 + 0.2          // ‚Üí 0.30000000000000004</p>
<p>0.1 + 0.2 === 0.3  // ‚Üí false ‚ùå</p>
<p>üö® *Non √® un bug di JavaScript ‚Äî √® una limitazione intrinseca dello standard IEEE 754, presente in tutti* i linguaggi che lo utilizzano per i numeri in virgola mobile (Python, C, Java, Go, ecc.).</p>
<h2> *üîπ 4\. Soluzioni Pratiche per l'Aritmetica*</h2>
<p>Per risolvere il problema dell'approssimazione in contesti critici (es. finanza), si usano tre approcci principali:</p>
<h3> *‚úÖ 1\. Lavorare con Interi (quando possibile)*</h3>
<p>Si eseguono i calcoli convertendo i decimali nell'unit√† pi√π piccola (centesimi, millesimi).</p>
<p>JavaScript</p>
<p>// ‚ùå Calcolo a rischio:</p>
<p>// const totale = 0.1 + 0.2;</p>
<p>// ‚úÖ Calcolo sicuro (in centesimi):</p>
<p>const totaleCentesimi = 10 + 20; // 30 centesimi</p>
<p>const totaleEuro = totaleCentesimi / 100; // 0.3</p>
<h3> *‚úÖ 2\. Usare la Tolleranza (Epsilon) nei confronti*</h3>
<p>Invece di verificare l'uguaglianza assoluta, si verifica se la *differenza assoluta* tra i due numeri √® inferiore a un valore molto piccolo (epsilon):</p>
<p>JavaScript</p>
<p>function sonoUguali(a, b, tolleranza = 1e-10) {</p>
<p>// 1e-10 √® 0.0000000001</p>
<p>return Math.abs(a - b) < tolleranza;</p>
<p>}</p>
<p>sonoUguali(0.1 + 0.2, 0.3); // ‚Üí true</p>
<h3> *‚úÖ 3\. Librerie Specializzate*</h3>
<p>Librerie come *decimal.js o big.js* forniscono tipi numerici dedicati per eseguire calcoli decimali con precisione arbitraria, aggirando il limite di IEEE 754\.</p>
<h2> *üîπ 5\. Limiti di Precisione: L'Intervallo Sicuro*</h2>
<p>Nonostante i 64 bit, non tutti gli interi sono rappresentabili in modo esatto a causa dei limiti della Mantissa (52 bit).</p>
<ul><li>L'intervallo sicuro (senza perdita di precisione per gli interi) √®:</li></ul>
<p>$$\[-2^{53} + 1,\\; 2^{53} - 1\]$$</p>
<h3> *Costanti Utili:*</h3>
<p>JavaScript</p>
<p>Number.MAX_SAFE_INTEGER // 9007199254740991</p>
<p>Number.MIN_SAFE_INTEGER // -9007199254740991</p>
<p>‚ö†Ô∏è Oltre questo range, la precisione viene persa:</p>
<p>JavaScript</p>
<p>9007199254740992 === 9007199254740993 // ‚Üí true\! ‚ùó (Questo √® un errore di precisione)</p>
<h2> *‚úÖ Riepilogo Finale*</h2>
<p># *üìò Lezione 2: Operatori Aritmetici e Manipolazione dei Numeri in JavaScript*</p></section>
        <footer>
            <p><strong>Corso:</strong> JavaScript - Da Zero ad Esperto</p>
            <p><strong>Lezione:</strong> 14 - IEEE 754 Approfondito</p>
        </footer>
    </div>
</body>
</html>